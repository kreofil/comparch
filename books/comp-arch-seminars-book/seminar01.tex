\chapter[RARS. Знакомство]{Семинар 1. Эмулятор RARS. Первоначальное знакомство}

\section{Цель и задачи}
\debate[Примечание] {
    На мой взгляд, изучение среды и особенностей организации системы команд имеет смысл начинать с непосредственного погружения по принципу: делай как я. Естественно, что первоначально не все будет понятно, но в ходе демонстрации можно уже начинать объяснять, что почему и как устроено, как это работает. Давать изначально голую теорию с последующей демонстрацией практически бесполезно. Особенно когда имеется такое наглядное пособие, как эмулятор. Исходя из этого можно при изучении среды сразу же совместить такие вопросы как: форматы команд, ассемблер, эмулятор RARS процессора RISC-V, особенности IDE, имитаторы системных вызово, используя для демонстрации простой пример. Часть информации может быть взята по ссылке:

    \url{http://uneex.org/LecturesCMC/ArchitectureAssembler2022/01_AboutRiscV}
}

Целью семинара является изучение основных особенностей эмулятора RARS, используемого в ряде семинаров для изучения особенностей архитектуры 32-разрядного процессора RISC-V. В ходе его проведения предполагается рассмотреть следующие вопросы.

\begin{enumerate}
    \item Получение общих сведений о работе эмулятора и мотивах его использования:
    \begin{itemize}
        \item Пояснение, почему используется эмулятор, а не реальная вычислительная система.
        \item Характеристики эмулятора и краткая история его создания.
        \item Что из себя представляет эмулятор RARS. Что он может.
    \end{itemize}
    \item Изучение процесса установки эмулятора на компьютеры с различной архитектурой и разными операционными системами.
    \begin{itemize}
        \item Где можно взять эмулятор RARS. Сайт эмулятора. Софт на Гитхаб.
        \item Установка эмулятора в различных операционных системах.
    \end{itemize}
    \item Демонстрация работы эмулятора на примере простых программ.
    \begin{itemize}
        \item Запуск эмулятора в режиме среды разработки.
        \item Основные компоненты эмулятора и их назначение.
        \item Особенности распределения адресного пространства памяти под программу и данные.
        \item Создание простейших программ на ассемблере RISC-V, их компиляция и запуск из среды эмулятора.
        \item Прогон готовых простых программ в автоматическом режиме и в режиме отладчика.
        \item Запуск эмулятора в режиме командной строки.
    \end{itemize}
\end{enumerate}

\section{Общие соображения}

\debate [AL]{Так как обычно лекции предшествуют семинарам, я постараюсь, особенно на первых лекциях, делать упреждающий рассказ об архитектуре процессора и его системе команд. Думаю, что половину этих лекций буду уделять общим вопросам, а другую часть конкретно архитектуре RISC-V и сопутствующим инструментальным средствам, чтобы студенты на занятиях имели начальное представление, и не было на семинарах соответствующего теоретического материала. Скореее всего это будут отдельные презентации, которые будут пополняться отдельно. Каждая из них будет выкладываться в соответствующую тему.}

Для проведения занятий предполагается использование компьютерного класса с установленной на компьютерах ОС Linux или Windows. В этом как раз и заключается особенность эмулятора, что можно его использовать в любой из ОС. Но имеет смысл разобраться: есть ли под установленной версией Linux пакет, содержащий RARS. Если да, то можно будет установить его из дистрибутива. Помимо этого для любой из ОС его можно непосредственно скачать из репозитория: \url{https://github.com/TheThirdOne/rars/releases}\\
Сам пакет можно будет скачать заранее и выложить в LMS.

\debate[AL]{Еще возможной проблемой (хотя вряд ли, так как java ориентирована на Юникод) может быть локализация. Нужно это тоже предварительно выяснить. Нужно предварительно поиграться с примерами программ на Windows, используя русскоязычные комментарии. В Linux обычно проблем нет. По крайней мере у меня. Но можно просто комментарии делать на английском или транслитом, если такие проблемы возникают.}

Традиционно на семинаре нужно будет использовать проектор. Но также думаю, что изначально можно будет запускать эмулятор RARS, проверив его работоспособность как под Linux, так и под Windows. Сценарий первого семинара в данном случае предполагает действия по принципу: делай как я. Начиная с простейших программ, состоящих из пары команд или псевдокоманд, можно перейти к системным вызовам обеспечивающим ввод-вывдо. То есть, общий алгоритм семинара можно выставить по схеме лекций Георгия Курячего. Но с непосредственным выполнением шагов студентами. По ходу демонстрации можно неоднократно открывать систему помощи и показывать информацию, которая там имеется, при комментарии выполняемых шагов.

\section{Сценарий семинара}
\subsection{Основные сведения об эмуляторе}
С мотивами использования эмулятора все просто. Это преодоление разнотипности различного железа и операционных систем. Эмулятор, реализованный на java, может быть запущен практически везде. С другой стороны для изучения конкретной архитектуры на уровне системы команд использование реального железа не является необходимым. Предлагаемый эмулятор, помимо системы команд позволяет изучить и много другое, включая программирование ввода-вывода, прерывания, кеш память, а также прогнозирование переходов. Также стоит отметить перспективу архитектуры и ее достаточную простоту по сравнению с CISC системами.

По поводу использования других систем эмуляции. Можно отметить, что их в настоящее время много. Зачастую они запускаются в виртуальных машинах, что позволяет использовать операционные системы и средства разработки на различных языках программирования. Имеются также системы кросс компиляции. Однако в рамках дисциплины эти вопросы не являются актуальными и поэтому не рассматриваются.

\subsection{Установка эмулятора}

Так как базовую информацию по основам архитектуры и системе команд я предполагаю дать на лекции, то можно сразу стартовать с мотивов использования эмулятора и его местоположения в сети. Также (особенно при проблемах доступа к эмулятору в сети, его можно будет установить (если еще не установлен) в домашний каталог из LMS. Думаю, что туда он предварительно ляжет.
Установить можно в любой домашний каталог и запускать используя консоль, как это делает Курячий. Если, конечно, он не запускается по умолчанию. Запуск в ОС Linux осуществляется в этом случае просто:
\begin{verbatim}
    java -jar rars1_6.jar
\end{verbatim}

\debate[AL]{У меня запуск эмулятора, установленного в домашний каталог, осуществляется по умолчанию как пакета java. Помимо этого в ряде дистрибутивов эмулятор может быть установлен из системного репозитория. Тогда он будет присутствовать в меню запуска. Это, например, реализовано в Manjaro Linux, а также в Simply Linux. Как запускаются подобные пакеты в Windows -- посмотрите, кто этой ОС пользуется. Думаю, что на Маке проблем тоже не возникнет.}

\subsection{Демонстрация работы эмулятора}
После запуска необходимо охарактеризовать основные окна, меню, инструментальные панели. Все как обычно. Обратить внимание на систему помощи и имеющиеся в ней разделы.

Продемонстрировать процесс использования простой программы расположенной в учебном каталоге: загрузку программы, ее компиляцию, запуск на выполнение. Выполнение в пошаговом режиме, в режиме точек останова. Можно это все делать по принципу: делай как я. При этом можно сразу не акцентировать внимание на распределении памяти эмулятора под программу, данные, ядро, адресное пространство ввода-вывода, так как это будет далее рассматриваться в ходе изучения архитектуры.

\subsubsection{Простейшая программа нахождения суммы двух чисел}
В качестве первого примера можно использовать программу, которая складывает пару чисел.
\begin{verbatim}
    li      a7 5        # Системный вызов №5 — ввести десятичное число
    ecall               # Результат — в регистре a0
    mv      t0 a0       # Сохраняем результат в t0
    ecall               # Регистр a7 не менялся, тот же системный вызов
    add     a0 t0 a0    # Прибавляем ко второму число первое
    li      a7 1        # Системный вызов №1 — вывести десятичное число
    ecall
    li      a7 10       # Системный вызов №10 — останов программы
    ecall
\end{verbatim}


Обратить внимание на то, что возможна компиляция как одного файла за один раз, так и всех файлов, расположенных в одном каталоге. Последнее позволяет осуществлять для эмулятора разработку многофайловых проектов. Для текущей работы предложить убрать флаг у параметра: <<SettingsAssemle all file iin directory>>, если он установлен. В этом случае будет компилироваться только один файл, расположенный в открытом окне редактора. Также можно поизучать и обсудить (но поверхностно) и другие флаги.

В ходе пояснения обсудить и пояснить отличие псевдокоманд от команд. Показать где и как это отличие отображается. Также рассмотреть на примере простейших программ изменение данных и регистров. Обсудить псевдонимы (алиасы) регистров и специализацию регистров в соответствии с соглашением по их использованию для данной архитектуры процессора. Пояснить использование регистра zero, а также концепцию разработчиков системы команд, направленную на устранение избыточных команд.

Подчеркнуть специфику системы команд RISC процессоров, связанную с тем, что форматы команд предназначены для организации эффективной работы процессора, а для написания программ человеком используются ассемблеры.

Это во многом отличает ассемблеры RISC систем от ассемблеров CISC процесооров, в которых обычно каждая машинная команда однозначно соответствует инструкции на ассемблере, а формат машинной команды имеет логически выстроенную структуру полей. В RISC процессора поля в формате команды распределены так, чтобы можно было обеспечить эффективную обработку в устройстве управления.

\debate[AL]{На данном этапе изучения можно (если не возникнут соответствующие вопросы) не останавливаться на специфике форматов команд. Правда можно сказать, что формат команд ориентирован на эффективность их обработки устройством управления процессора, а не на программиста. Пояснить, что на программиста ориентирован ассемблер, в котором есть удобные мнемоники как для команд, так и псевдокоманд. Все эти вопросы также будут многократно повторяться в ходе изложения лекционного материала.}

После этого можно приступить к обсуждению и демонстрации эмуляции простых системных вызовов (ecall), обеспечивающих ввод-вывод целочисленных данных. Пояснить, что это не вызовы ОС, а обращение к библиотекам java, которые и занимаются соответствующей эмуляцией. Но во многом эти вызовы похожи на вызовы, осуществляемые в операционных системах. Показать, где эти вызовы описаны в системе помощи эмулятора.

\subsubsection{Первая программа из серии <<Hello>>}
На примере этой программы можно рассмотреть использование системного вызова, осуществляющего вывод строки, представленной в формате языка Си (завершающейся нулем).
\begin{verbatim}
.text
    la a0, string       # buffer
    li a7, 4            # syscall write (4)
    ecall
    li a0, 0            # exit code
    li a7, 10           # syscall exit
    ecall
.data
    string:  .asciz "Hello! It works!!!\n"
\end{verbatim}
Можно пояснить, что еще есть строки которые могут не завершаться нулем. Но этом вариант достаточно удобен для организации вызова.

Помимо этого обратить внимание (в поверхностном варианте) на распределением памяти в эмуляторе. Пояснить, откуда начинается адресное пространстов данных. Задание адресных пространств данных и кода директивами \verb|.data|  и \verb|.text|.

\subsubsection{Вторая программа из серии <<Hello>>}
На примере этой программы показать, что непринципиально, в какой последовательности следуют описания данных и кода.

\begin{verbatim}
    .data
hello:
    .asciz "Hello, world!"
    .text
main:
    li a7, 4
    la a0, hello
    ecall
\end{verbatim}

\subsubsection{Третья программа из серии <<Hello>>}
В принципе можно чередовать секции кода и данных. Они в конце концов соберутся правильно.
\begin{verbatim}
.text
    la a0, string       # buffer
    li a7, 4            # syscall write (4)
.data
    string:  .asciz "Hello! It works!!!\n"
.text
    ecall
    li a0, 0            # exit code
    li a7, 10           # syscall exit
    ecall
\end{verbatim}

\subsubsection{Четвертая программа из серии <<Hello>>}
Можно также посмотреть, как будут представлена кириллица при выводе данных. В принципе в Java (на чем написан эмулятор) используется Юникод. Но посмотреть стоит, что будет под разными ОС.
\begin{verbatim}
.text
    la a0, string       # buffer
    li a7, 4            # syscall write (4)
    ecall
    li a0, 0            # exit code
    li a7, 10           # syscall exit
    ecall
.data
    string:  .asciz "Привет. Русский язык выглядит так!!!\n"
\end{verbatim}
В целом при выводе все должно быть нормально. Но отображение не \verb|ascii| символов в памяти может не получитья. Только в шестнадцатиричном формате. Для демонстрации можно поиграться флажками, которые определяют формат вывода дампа памяти.

\subsubsection{Еще раз сложение двух чисел}
При наличии времени (или в быстром режиме) можно сделать обзор программы сложения двух числе, котора выводить дополнительные сообщения перед вводом или выводом данных.
\begin{verbatim}
.data
    arg01:  .asciz "Input 1st number: "
    arg02:  .asciz "Input 2nd number: "
    result: .asciz "Result = "
    ln:     .asciz "\n"
.text
    la 	a0, arg01   # Подсказка для ввода первого числа
    li 	a7, 4       # Системный вызов №4
    ecall
    li      a7 5    # Системный вызов №5 — ввести десятичное число
    ecall           # Результат — в регистре a0
    mv      t0 a0   # Сохраняем результат в t0

    la 	a0, arg02   # Подсказка для ввода второго числа
    li 	a7, 4       # Системный вызов №4
    ecall
    li      a7 5    # Системный вызов №5 — ввести десятичное число
    ecall           # Результат — в регистре a0
    mv      t1 a0   # Сохраняем результат в t1

    la a0, result   # Подсказка для выводимого результата
    li a7, 4        # Системный вызов №4
    ecall
    add   a0 t0 t1  # Складываем два числа
    li      a7 1    # Системный вызов №1 — вывести десятичное число
    ecall

    la a0, ln       # Перевод строки
    li a7, 4        # Системный вызов №4
    ecall

    li      a7 10   # Системный вызов №10 — останов программы
    ecall
\end{verbatim}

\subsection{Использование эмулятора в режиме командной строки}

На данном этапе изучения достаточно продемонстрировать простейшие действия с представленными выше программами. То есть, показать, каким образом можно осуществить ассемблирование программы, а также ее запуск на выполнение. Предполагается, что более детальное рассмотрение (если это будет необходимо) будет сделано в ходе последующих семинаров.

\section{Разное}
При демонстрации программ основной упор делать на особенности организации среды. Можно часто обращаться к системе помощи программы для демонстрации различных особенносте в моменты рассмотрения тех или иных вопросов.

Привести ссылки на используемые источники, указав, какая тема затронута. Сами источники в конце методы. Они могут быть общими для всех документов.

\section{Домашнее задание}

\subsection{Оценка до 8 баллов}

Установить RARS и запустить в нём программы, размещенные в LMS (в теме первого семинара).  Сформировать отчет об использовании эмулятора, в котором привести скриншоты, демонстрирующие работу эмулятора с этими программами.

В отчете описать, какие команды являются псевдокомандами, проанализировав для этого результаты компиляции одной из программ.

Описать типы форматов команд для одной из представленных программ.

Описать какие системные вызовы используются в изученных программах. Для этого достаточно обратиться к системе помощи эмулятора.

\subsection{Опционально +2 балла}

Записать на видео процесс работы эмулятора с этими программами в режимах компиляции и автоматического выполнения. Одну из программ выполнить в пошаговом режиме с комментариями.
