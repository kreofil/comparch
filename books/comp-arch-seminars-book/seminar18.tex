\chapter[18]{Семинар 18. Программирование ввода--вывода. Использование прерываний}

Целью семинара является продолжение изучения базовых механизмов синхронизации POSIX Threads, обеспечивающих совместное безконфликтное использование ресурсов. Необходимо провести анализ примеров, демонстрирующих различные методы синхронизации и того, что может получиться при отсутствии синхронизации.

Изучение примеров с OpenMP, прилагающихся к лекциям. Предыдущие и эти примеры достаточно короткие. Поэтому можно просто пробежаться. Вполне возможно, что OpenMP придется установить. Обычно пакет openmp. На Убунте не пробовал. Попробую --- сообщу. Все эти примеры я планирую показать на лекции. Но для раздолбаев, которые на лекции не ходят, может оказаться полезным. Заодно все узнают, как установить библиотеку.

После этих примеров обсудить результаты выполнения заданий.

Примерный перечень вопросов (часть перенесена из предыдущего семинара, так как не рассматривалась на лекции):
\begin{enumerate}
    \item Пример 04 (10. Читатели-писатели с общим одномерным массивом. Использование блокировок). Здесь, наверное, можно поиграться только с разными интенсивностями работы читателей и писателей. Тем более, что читатели ничего не меняют. Можно поиграться числом разных потоков или интенсивностью их обращения. В целом основной акцент на самом механизме организации блокировок и поведении участников. В целом ничего хитрого в пояснении и использовании я не вижу.
    \item Пример 05 (11. Использование барьеров для синхронизации данных). Пример интересен именно тем, где и как убирать или ставить барьеры. Именно они влияют на синхронизацию двух разделенных массивов. Вариант одного барьера закомментирован. С двумя другими можно тоже поиграться, посмотрев разные варианты. Вплоть до отсутствия барьеров. Мьютексы отвечают за вывод. Поэтому их трогать смысла особого нет. Но тоже можно посмотреть, если будет время. Ключевая идея связана с независимостью данных и использования барьеров для согласованного изменения своих массивов.
    \item Пример 06 (01. Многопоточный вывод "Hello World"). Данный пример прост. На нем можно увидеть, как работает прагма \verb|#pragma omp parallel|. Можно ее отключить и посмотреть, что получится. Основная идея --- рассмотреть две функции, которые определяют число возможных потоков по ядрам системы и номер текущего потока. Каждый поток обрабатывается независимо и выводит свои данные.
    \item Пример 08 (02. Использование критической секции. Шаг 1). Пример показывает использование критической секции \verb|#pragma omp critical|. В данном случае общая переменная изменяется произвольно, а синхронизация осуществляется по выводу. Как раз можно оценить, что происходит с этой переменной при неправильной установке критической секции.
    \item Пример 09 (03. Использование критической секции. Шаг 2). В этом примере критическая секция установлена на переменной. Но не на выводе данных. Тоже полезно посмотреть рассогласование вывода. Как и в предыдущем случае можно запустить несколько раз, чтобы отследить недетерминированность.
    \item Пример 10 (04. Использование критической секции. Шаг 3). Окончательный пример по критической секции. Имеется выбор конкретного числа потоков. Можно поиграться с этим. Также можно посмотреть потоки с использованием системного монитора. Также там описано использование редукции. Можно поиграться с различными прагмами распараллеливания.
    \item Пример 11 (05. Вычисление интеграла с использованием редукции). Разные варианты и число потоков для просмотра. Тоже можно поиграться с режимами.
\end{enumerate}

Во всех альтернативных программах можно использовать код как на Си, так и на плюсах. Они работают одинаково.

Пусть студенты сами сделают прогоны и сформируют результаты.

\section{Домашнее задание}

Установить на домашней системе openMP и прислать отчет (в виде сканов), демонстрирующих выполнение программы вычисления интеграла с использованием openMP. Использовать свои данные, изменив в программе функцию, используемую для интегрирования и интервалы интегрирования. Три варианта запуска с разными интервалами.
