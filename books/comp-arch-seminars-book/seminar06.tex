\chapter[Подпрограммы. Окончание]{Семинар 06. Подпрограммы. Стек. Кадр стека. Параметры. Локальные переменные}

Целью семинара является продолжение изучения подпрограмм на уровне систмы команд. Основной упор при этом делается на роль стека в современном программировании не только на ассемблере, но и в языках высокого уровня.

На занятии предполагается рассмотреть следующие темы:
\begin{enumerate}
    \item Пояснение специфики использования стека и его организации в целом. Привязаки стека к памяти.
    \item Особенности работы со стеком в RISC-V. Основные команды. Стек как хранилище, альтернативное общей памяти.
    \item Использование стека для дополнительных фактических параметров.
    \item Использование стека для локальных переменных подпрограммы и дополнительных фактических параметров.
    \item Разработка рекурсивных подпрограмм.
    \item Соглашения о вызовах подпрограмм, использовании регистров. Кадр стека.
    \item Выдача индивидуального задания №~1. Установка сроков и регламента сдачи индивидуальных заданий.
\end{enumerate}

\section{Общая специфика использования стека}
В принципе уже прописано в презентации. Скорее всего он также изучен в дисциплине "Алгоритмы и структуры данных". Поэтому сильно акцентироваться не стоит. Достаточно дать основные определения. Можно подчеркнуть, что стек на уровне архитектур ВС обычно представляет собой линейное пространство памяти. Оно может быть выделено в любом месте. Но чаще всего в верхних адресах. Стек может расти с нижних адресов вверх, хотя чаще реализуется таким образом, что с верхних адресов растет вниз навстречу куче.

Остановиться на специфике размещения стека в памяти эмулятора RARS.

\section{Особенности работы со стеком в RISC-V}
Пояснить, что в принципе для работы со стеком нет специальных команд и любой регистр может являться указателем на вершину стека. Вместе с тем, под указатель стека соглашением выделен регистр \verb|x2|, который имеет псевдоним \verb|sp|.

Далее на примере (уже есть в презентации) рассмотреть использования стека в пошаговом режиме. Посмотреть в эмуляторе, как изменяются регистры процессора и память, отведенная под стек.

Здесь же можно отметить, что на стеке обычно сохраняется и адрес возврата из подпрограммы, что позволяет организовать иерархические вложенные вызовы подпрограмм, а также обеспечить выполнение рекурсивных подпрограмм.

\section{Использование стека для дополнительных фактических параметров}

Рассказать, что если передаваемых в подпрограмму параметров много, и они не размещаются в регистрах, то обычно используется стек, в который эти параметры и ложатся.


\section{Использование стека для локальных переменных подпрограммы}

Аналогичным образом пояснить использовани и хранение на стеке локальных переменных. Можно также сказать (возможно еще раз), что это сохранение бывает более эффективным, чем в глобальной памяти за счет того, что поддерживает одной командой загрузки в стек или чтения из него по сравнению с обращением по абсолютному адресу.

\section{Разработка рекурсивных подпрограмм}

Показато на примерах работу с рекурсивными подпрограммами.

\section{Соглашения о вызовах подпрограмм, использовании регистров. Кадр стека}

Суммировать материал об основных соглашениях, связанных с организацией подпрограмм, ролевым распределением регистров, выделением регистров \verb|s*| в качеств сохраняемых на стеке и т.д.

\section{Домашнее задание}

\subsection{До 8 баллов}
Разработать программу, определяющую максимальное значение аргумента, при котором результат вычисления факториала размещается в 32-х разрядном машинном слове. Вычисление факториала организовать как подпрограмму с циклом, которая возвращает найденный аргумент в регистре a0. Вывод результатов должна осуществлять главная функция.

\subsection{Опционально до +2 баллов}
Дополнительно реализовать решение предыдущей задачи с использованием рекурсивной подпрограммы вычисления максимального значения аргумента, при котором результат вычисления факториала размещается в 32-х разрядном машинном слове.


