\chapter[Регистры. Память. Данные. Команды]{Семинар 02. Регистры. Организация памяти. Директивы. Описание данных.}

\section{Цель и задачи}

Целью семинара является знакомство с организацией регистров и памяти эмулятора процессора RISC-V, Методов представления данных в памяти, распределения пространства памяти с использованием различных директив. Помимо этого предполагается изучение директив, разделяющих данные и код, а также вариантов их использования.

\begin{enumerate}
    \item Регистры.
    \begin{itemize}
        \item Особенности организации целочисленных регистров процессора, их имена и алиасы.
        \item Специализация ряда регистров.
        \item Соглашения по использованию регистров.
    \end{itemize}
    \item Соглашения об использовании модели памяти в RARS
    \begin{itemize}
        \item Общее понятие о моделях памяти. Контекст программы (процесса).
        \item Области (секции) памяти и распределение адресного пространства.
        \item Отображение областей памяти в ассемблере.
        \item Отображение областей памяти в RARS.
    \end{itemize}
    \item Описание данных различного типа на ассемблере в области данных.
    \begin{itemize}
        \item Мнемонические обозначения для данных различного типа и их задание соответсвующими константами.
        \item Резервирование областей памяти заданного размера.
        \item Выравнивание в памяти.
    \end{itemize}
\end{enumerate}

\section{Сценарий семинара}

\debate[Примечание]{
    По сути в рамках семинара предполагается рассмотреть, каким образом описываются данные и выполняются команды, связанные с адресацией памяти, используемой в процессоре. Также необходимо затронуть, на какие форматы команд накладываются те или иные методы адресации.
    Информация во многом соответствует содержанию страницы на сайте Георгия Курячего:\\
    \url{http://uneex.org/LecturesCMC/ArchitectureAssembler2022/02_MemoryRegisters}\\
}

Имеет смысл лишний раз подчеркнуть специфику системы команд RISC процессоров, связанную с тем, что форматы команд предназначены для организации эффективной работы процессора, а для написания программ человеком используются ассемблеры.

Также стоит отметить, что принятые специальные соглашения (конвенции) об использовании регистров (их виртуальной специализации) помогают писать совместимые и переносимые программы. Помимо этого разработчики процессоров могут использовать эти соглашения (включая и соглашения по замене псевдокоманд конкретными командами) для оптимизации аппаратных решений, что обеспечивает повышение производительности систем.

\subsection{Регистры процессора}

Основная идея в представлении регистров заключается в пояснении их количества, а также вариантов использования в соответствии с изначально принятыми соглашения. Рассказать, для чего предназначены соглашения по использованию регистров. Также пояснить почему ряд регистров реализованы с соответствующей специализацией. При этом можно более подробно остановиться на специализации отдельных регистров. Можно также вкратце отметить, что делают, когда количество параметров при вызове некоторой функции превышает число выделенных для этого регистров. Обычно при нехватке регистров оставшиеся параметры выкладываются на стек. Но на данном этапе заострять внимание на этом нет смысла. Также сказать. Почему не все параметры размещают на стеке, что было раньше. Пояснить это повышением производительности и увеличением числа регистров.

\debate[Примечание]{Размещение на стеке для RISC-V я пока это не смотрел. Но в дальнейшем при изучение процедур к этому стоит вернуться.}

Таблица~\ref{table-registers} описывает особенности распределения и использования регистров.

\begin{table}[h]
    \caption{Обозначение и использование регистров процессора}
    \centering
    \begin{tabularx}{\textwidth}{|c|c|X|}
        %\rowcolor{lightgray}
        \hline
        \textbf{Регистры} & \textbf{Псевдонимы} & \textbf{Соглашения по использованию} \\
        \hline %\hline
        x0 & zero & Всегда равен 0 (hard-wired zero) \\
        \hline
        x1 & ra & Адрес возврата (return address) \\
        \hline
        x2 & sp & Указатель стека (stack pointer) \\
        \hline
        x3 & gp & Адрес области глобальных данных (global pointer) \\
        \hline
        x4 & tp &  Указатель потока (thread pointer) \\
        \hline
        x5--x7 & t0--t2 & Временные регистры 0--2 (temporaries 0--2) \\
        \hline
        x8 & s0, fp & Сохраняемый регистр 0 или указатель фрейма (saved register 0, frame pointer) \\
        \hline
        x9 & s1 & Сохраняемый регистр 1 (saved register 1) \\
        \hline
        x10--x17 & a0--a7 & Регистры параметров подпрограмы и возврата значений из них (function arguments 0 to 7) \\
        \hline
        x18--x27 & s2--s11 & Сохраняемые регистры 2--11 (saved registers 2--11) \\
        \hline
        x28--x31 & t3--t6 & Временные регистры 3--6 (temporaries 3--6) \\
        \hline
        pc & pc & Указатель команд (program counter) \\
        \hline
    \end{tabularx}
    \label{table-registers}
\end{table}

\subsection{Распределение адресного пространства памяти}
Дать пояснения что практически во всех системах осуществляется распределение области памяти между различными программами в соответствии с принятыми соглашениями, что позволяет упростить процесс распределения соответствующего ресурса. В эмуляторы RARS тоже приняты соответствующие соглашения и поддерживаются соответствующие модели памяти, упрощающие разработку программ. Рассказать о принятых типовых соглашениях. Для этого можно сослаться на то, как в существующих ОС формируется контекст программы (процесса) на примере программы, написанной на Си.

\debate[Примечание] {Соответствующий материал будет представлен в методе для самостоятельной работы. Он уже сформирован по предшествующим годам. Возможно он также будет представлен и в лекционных материалах.}

Таблица~\ref{table-memory} описывает соглашения, принятые для распределения адресного пространства памяти в эмуляторе RARS.

\begin{table}[h]
    \caption{Соглашения по распределению памяти эмулятора RARS}
    \centering
    \begin{tabularx}{\textwidth}{|c|c|X|}
        \hline
        %\rowcolor{lightgray}
        \textbf{Адреса} & \textbf{Назначение} & \textbf{Целевое выделение памяти} \\
        \hline %\hline
        %\rowcolor{yellow}
        \texttt{0xffffffff} & \textbf{Память устройств} & Последний адрес, доступный ядру (highest address in kernel) \\
        \hhline{~~-}
        %\rowcolor{yellow}
                            &  & Конец памяти устройств (memory map limit address) \\
        \hhline{-~-}
        %\rowcolor{yellow}
        \texttt{0xffff0000} &  & Начало памяти устройств  (MMIO base address) \\
        \hhline{---}
        %\rowcolor{pink}
        \texttt{0x80000000} & \textbf{Область памяти ядра} & Начало памяти ядра (Начало памяти ядра) \\
        \hline
        %\rowcolor{lime}
        \texttt{0x7fffffff} & \textbf{Область данных} & Последняя ячейка, доступная пользователю (highest address in user space) \\
        \hhline{~~-}
        %\rowcolor{lime}
        \texttt{0x7fffffff} &  & Последняя ячейка области данных (data segment limit address) \\
        \hhline{-~-}
        %\rowcolor{lime}
        \texttt{0x7ffffffc} &  &  Адрес исчерпания стека (↓ stack base address) \\
        \hhline{-~-}
        %\rowcolor{lime}
        \texttt{0x7fffeffc} &  &  Сюда указывает регистр стека. Растёт вниз (↓ stack pointer sp) \\
        \hhline{-~-}
        %\rowcolor{lime}
        \texttt{0x7fffeffc} &  &  Сюда указывает регистр стека. Растёт вниз. (↓ stack pointer sp) \\
        \hhline{-~-}
        %\rowcolor{lime}
        \texttt{0x10040000} &  &  Нижняя граница роста стека (stack limit address) \\
        \hhline{~~-}
        %\rowcolor{lime}
                            &  &  Начало кучи. Растёт вверх (↑ heap base address) \\
        \hhline{-~-}
        %\rowcolor{lime}
        \texttt{0x10010000} &  &  Начало статических данных (.data base Address) \\
        \hhline{-~-}
        %\rowcolor{lime}
        \texttt{0x10008000} &  &  Сюда указывает регистр глобальных данных (global Pointer gp) \\
        \hhline{-~-}
        %\rowcolor{lime}
        \texttt{0x10000000} &  &  Область глобальных данных (.extern base address) \\
        \hhline{~~-}
        %\rowcolor{lime}
                            &  &  Начало области данных  (DATA Segment base address ) \\
        \hline
        %\rowcolor{lime}
        \texttt{0x0ffffffc} & \textbf{Область кода} &  Последняя ячейка области программного кода (text limit address) \\
        \hhline{-~-}
        %\rowcolor{lime}
        \texttt{0x00400000} &  &  Начало программы (.text base address ) \\
        \hhline{~~-}
        %\rowcolor{lime}
                            &  &  Начало области программного кода (TEXT segment base address) \\
        \hline
        %\rowcolor{red}
        \texttt{0x00000000} & \textbf{Зарезервировано} &   \\
        \hline
    \end{tabularx}
    \label{table-memory}
\end{table}

\subsection{Директивы для размещения данных в памяти}

В рамках данной темы предлагается разместить данные в памяти и рассмотреть с использованием средств эмулятора их размещение после ассемблирования. Рассмотреть, каким образом осуществляется размещение в памяти для используемых в эмуляторе типов данных:
\begin{itemize}
    \item \texttt{.word} число --- одно или несколько 4-байтовых чисел;
    \item \texttt{.dword} число --- одно или несколько 8-байтовых чисел;
    \item \texttt{.half} число --- одно или несколько 2-байтовых чисел;
    \item \texttt{.byte} число --- одно или несколько однобайтовых чисел;
    \item \texttt{.ascii} строка" --- последовательность символов в кодировке ASCII;
    \item \texttt{.asciz} строка" --- последовательность символов в кодировке ASCII в конце которой добавляется нулевой байт (строка в стиле языка программирования Си).
    \end{itemize}
Изначально можно создать только одну секцию данных. После этого можно добавить код, который выводит данные с использованием системных вызовов.

Пример (из материалов Курячего):
\begin{verbatim}
.data
    .word   0xdeadbeef
    .dword  0xacebad0feeded
    .half   0x1234, 0x5678
    .byte   12, 13, 14, 15
    .half   0x3344
    .byte   0x66, 0x77
\end{verbatim}

Предложить набрать (или скопировать с LMS) данный код и откомпилировать его. Рассмотреть, каким образом оно ляжет в памяти эмулятора. Сравнить с демонстрацией на проекторе. Основная задача --- закрепление навыков работы с эмулятором.
Результат трансляции пословно:
\begin{verbatim}
    10010000: deafbeef d0feeded 000aceba 56781234 0f0e0d0c 77663344
\end{verbatim}
Обратить внимание, что секция \verb|.data| начинается по умолчанию с адреса \verb|0x10010000|), а данные расположены в формате little endian (младший байт в слове имеет меньший адрес). Можно также поиграться с разными форматами отображения памяти, придоставляемыми эмулятором.

В рамках следующего задания рассмотреть, каким образом можно зарезервировать адресное пространство под данные, которые будут формироваться во время вычислений (\verb|.space|). В частности, под массивы данных. Обсудить соответсвтующие директивы. Помимо этого затронуть необходимость выравнивания данных и соответствующие директивы, демонстрирующие это (\verb|.align|). Все эти вопросы, как и в случае предыдущего примера, можно рассмотреть на соответствующем коде:
\begin{verbatim}
    #
    # Example: Data and its alignment.
    #
    .data
        .space 3
        word1:
        .word  0x12345678
        half1:
        .half  0x1234
        byte1:
        .byte  0x12
        .align 4
        word2:
        .word 0x12345678
        .align 3
        half2:
        .half  0x1234
        .align 3
        byte2:
        .byte  0x12
        .align 0
        word3:
        .word 0x12345678
\end{verbatim}
Откомпилировать данный код и посмотреть полученное распределение в памяти.
