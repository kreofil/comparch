\chapter[Обработка строк символов]{Семинар 11. Обработка строк символов. Тексты. Файлы}

Цель семинара --- изучение команд и методов, обеспечивающих обработку строк символов. В данном случае акцент предлагается сделать на использовании кодировки ASCII, так как все кодировки, превышающие крайнее значение 127 либо различны в разных ОС, либо, как Юникод, требуют дополнительных алгоритмических решений, что не является задачей данной дисциплины. То есть, речь идет о байтах, их обработке и передаче в обе стороны между регистрами и памятью.

Помимо этого имеет смысл затронуть вопросы, связанные с использованием файлов в эмуляторе RARS, так как работа с текстами --- это работа не с парой символов. Также работа с файлами будет в третьем задании на обработку строк символов.

На занятии предполагается рассмотреть следующие вопросы, связанные с обработкой строк символов:
\begin{enumerate}
    \item Особенности обработки символов в процессоре RISC-V. Используемые команды.
    \item Примеры обработки строк символов на основе воспроизведения некоторых функций библиотки \verb|string.h| языка программирования \verb|C|.
    \item Организация работы с файлами в RARS.
    \item Использование файлового ввода вывода для загрузки и выгрузки текстов.
    \item Примеры обработки текстов (с использование уже написанных подпрограмм).
\end{enumerate}

\section{Особенности обработки символов в процессоре RISC-V}

Обработку строк символов предлагается показать на примере трех программ:
\begin{itemize}
    \item вычисление длины строки, ограниченной нулевым символом;
    \item вычисление длины строки, ограниченной нулевым символом или числом просматриваемых символов;
    \item сравнение на равенство двух строк символов, ограниченных нулем.
\end{itemize}
Думаю, что этого для демонстрации будет более чем достаточно. Предлагаемые подпрограммы реализованы в стиле Си. Поэтому можно, используя \verb|man|, посмотреть их описание. Или в Интернете. Также у меня есть версии этих функций написанных на Си. Поэтому их можно предварительно изучить и запустить.

\subsection{Вычисление длины строки, ограниченной нулем}

Данная программа весьма проста и понятна. На Си она по сути занимает одну строчку. Однако следует отметить недостаток, связанный с контролем выхода за границы памяти. Примеры программ, демонстрирующих эту подпрограмму и тесты ее представлены в каталоге \verb|03-strlen|.

\subsection{Вычисление длины строки, ограниченной нулем или числом анализируемых символов}

Основная идея подобного ограничения является обычно в дополнительной проверке буфера на переполнение, которое может возникать по разным причинам. Например, при наложении данных друг на друга. Это возможно в небезопасных языках программирования, к которым относятся Си и Ассемблеры. Примеры на Си и Ассемблере расположены в каталоге \verb|04-strnlen| и демонстрируют, ситуацию, когда строка может оказаться длиннее размера буфера. В этом случае возвращается ошибка в виде значения длины, равного -1.

\subsection{Сравнение на равенство двух строк символов, ограниченных нулем}

В целом пример аналогичен предыдущим. Основная его идея заключается в обработке и сопоставлении символьных данных. Пример расположен в каталоге \verb|05-strcmp|. Нет ничего особенного, что хотелось бы отметить. Просто еще одна функция из библиотеки языка Си.

\section{Примеры подпрограмм и макроосов обработки строк символов}

Для завершения темы подпрограмм хотелось бы рассмотреть варианты объединения всего кода в подобие библиотек подпрограмм и макроопределений. Для этого подпрограммы из предыдущих примеров вынесены в отдельные файлы (можно было их все вынести в один общий файл, что непринципиально). Пример размещен в каталоге \verb|06-string-macro|. Помимо этого над каждой из подпрограмм сформировано макроопределение, все макроопределения собраны в файл макробиблиотеки \verb|macro-string.m|. Файл с подпрограммой \verb|main| демонстрирует тесты предлагаемых макросов. Дополнительно в примере подключается макробиблиотека системных вызовов \verb|macro-syscalls.m|. По сути это ранее рассмотренная библиотека макросов. Но планируется в ней сформировать все обращения к системным вызовам и использовать с другими программами. Думаю, что это может войти в дальнейшую методу.

\section{Организация работы с файлами в RARS}

Взаимодействие с файлами осуществляется через имитацию системных вызовов. Перечень этих вызовов приведет в таблице~\ref{table-file-syscalls}.

\begin{table}[h]
    \caption{Системные вызовы, обеспечивающие работу с файлами в симуляторе RARS}
    \centering
    \begin{tabularx}{\textwidth}{|l|c|X|X|X|}
        \hline
        \textbf{Вызов} & \textbf{Номер} & \textbf{Описание} & \textbf{Вход} & \textbf{Выход}\\
        %\hline  \multicolumn{3}{|c|}{\textbf{\textit{Арифметические}}} \\
        \hline \verb|Close| & 57 & Close a file & a0 = the file descriptor to close & N/A \\
        \hline \verb|LSeek| & 62 & Seek to a position in a file & a0 = the file descriptor a1 = the offset for the base a2 is the begining of the file (0), the current position (1), or the end of the file (2) & a0 = the selected position from the beginning of the file or -1 is an error occurred \\
        \hline \verb|Read| & 63 & Read from a file descriptor into a buffer & a0 = the file descriptor a1 = address of the buffer a2 = maximum length to read & a0 = the length read or -1 if error \\
        \hline \verb|Write| & 64 & Write to a filedescriptor from a buffer & a0 = the file descriptor a1 = the buffer address a2 = the length to write & a0 = the number of charcters written \\
        \hline \verb|Open| & 1024 & Opens a file from a path Only supported flags (a1) are read-only (0), write-only (1) and write-append (9). write-only flag creates file if it does not exist, so it is technically write-create. write-append will start writing at end of existing file. & a0 = Null terminated string for the path a1 = flags & a0 = the file decriptor or -1 if an error occurred \\
        \hline \verb|| &  &  &  & \\
        \hline
    \end{tabularx}
    \label{table-file-syscalls}
\end{table}
Рассмотрим использование некоторых из этих вызовов в эмуляторе RARS.

\debate[TODO. Стоит затем перенести в текст]{Для организации диалогового ввода и формирования более короткого пути к рабочим каталогам могут оказаться полезными ряд опций в меню \texttt{Settings}. Опция \texttt{Popup dialog for input syscalls (5,6,7,8,12)} позволяет установить для ввода данных отдельное диалоговое окно, в котором допускается ввод до 255 символов (байт). При этом введеннае в диалоге строка копируется в консоль, дублируя по сути ввод пользователя. Опция \texttt{Derive current working directory} позволяет указывать имена файлов относительно текущей рабочей директории. Это позволяет не пользоваться абсолютными путями и писать более короткие имена файлов, устанавливаемых в диалоге или в виде строк символов.}
\debate[Примечание]{На использование этих опций стоит обратить внимание на семинаре. Следует отметить, что относительные (точечные) имена файлов тоже прекрасно работают. Возможно также, что в примерах имеет смысл обратить внимание и на другие системные вызовы, формирующие диалоги. Также, думаю, что стоит сформировать файл макроопределений, задающих определения для системных вызовов. Будет удобно.}

\subsection{Запись данных в файл}

Я немного модифицировал пример, который присутствует в системе помощи (при описании системных вызовов). Добавил ввод с консоли имени файла для записи данных. Сдела простую обработку, заменяющую ввод пустого имени на имя файла по умолчанию. В целом же пример (каталог\texttt{write-file}) остался без каких-либо других изменений. После ввода имени файла выводится в него строка из буфера. На основе данного примера можно разобрать системные вызовы, связанные с открытием и закрытием файлов, понятие дескриптора. Можно приостановить вычисления и посмотреть в регистре номер дескриптора. Также можно разобрать работу вызова записи в файл.

\begin{verbatim}
# Sample program that writes to a new file.
.eqv	NAME_SIZE 256	# Размер буфера для имени файла

.data
prompt:  .asciz "Input file path: "     # Путь до читаемого файла
er_name_mes: .asciz "Incorrect file name\n"
default_name: .asciz "testout.txt"      # Имя файла по умолчанию
# Это выводимый текст
buffer: .asciz "The quick brown fox jumps over the lazy dog."
file_name: .space	NAME_SIZE		# Имя читаемого файла

.text
###############################################################
# Ввод имени файла с консоли эмулятора
la		a0 file_name
li      a1 NAME_SIZE
li      a7 8
ecall
# Убрать перевод строки
li  t4 '\n'
la  t5  file_name
mv  t3 t5	# Сохранение начала буфера для проверки на пустую строку
loop:
lb	t6  (t5)
beq t4	t6	replace
addi t5 t5 1
b   loop
replace:
beq t3 t5 default	# Установка имени введенного файла
sb  zero (t5)
mv   a0, t3 	# Имя, введенное пользователем
b out
default:
la   a0, default_name # Имя файла по умолчани
###############################################################
out:
# Open (for writing) a file that does not exist
li   a7, 1024     # system call for open file
li   a1, 1        # Open for writing (flags are 0: read, 1: write)
ecall             # open a file (file descriptor returned in a0)
mv   s6, a0       # save the file descriptor
###############################################################
# Write to file just opened
li   a7, 64       # system call for write to file
mv   a0, s6       # file descriptor
la   a1, buffer   # address of buffer from which to write
li   a2, 44       # hardcoded buffer length
ecall             # write to file
###############################################################
# Close the file
li   a7, 57       # system call for close file
mv   a0, s6       # file descriptor to close
ecall             # close file
###############################################################
\end{verbatim}

\debate[Примечание]{Отступы нарушены. Поэтому лучше использовать примеры непосредственно из файла кода.}

\subsection{Чтение данных из файла}

Обратная задача чтения данных из файла связана с тем, что необходимо иметь буфер соответствующего размера (каталог \verb|read-file|). Также необходимо проверять имя файла при открытии на наличие. Это делается просто по возврату -1 системным вызовом \verb|Open|. В данном случае файл читается в буфер. Делается попытка заполнить весь буфер за один раз. Если файл короче, то возвращаемое количество прочитанных байт будет меньше длины буфера. Зная это число, в конце можно поставить нулевой ограничитель строки и вывести файл соответствующим системным вызовом. Если же файл имеет длину, большую, чем буфер, он заполнит буфер только своей считанной частью. Пример подводит к тому, что слишком большие файлы, которые не умещаются в буфер (а часто мы не знаем размер файла), должны читаться по частям. Возможно с расширением буфера с использованием, например, динамической памяти.

\debate[Примечание]{Это будет следующий пример по чтению-записи файлов. В текущем примере вложен файл \texttt{strcmp.c} для демонстрации ввода файла, размещаемого в буфере. Файлом, который не размещается в буфере, является код программы.}

\section{Примеры обработки текстов}

Программа представленная в каталоге \verb|09-load-text|, осуществляет ввод данных из большого файла, их отображение в консоли и вывод данных в другой файл. Имена входного и выходного файлов задаются в диалоге. Ее особенностью является ограниченный по размеру буфер, используемый для чтения из файла. Поэтому чтение данных осуществляется в цикле. В этом же цикле осуществляется динамическое расширение данных под читаемые данные в процессе их поступления. В принципе подход может быть использован для любых файлов, но в примере осуществляется вывод данных в консоль. Поэтому он ориентирован только на текстовые файлы.

Наряду с этим в программе расширена библиотека макросов, поддерживающая системные вызовы. Также для демонстрации используется внешняя подпрограмма, определяющая длину сформированной из файла строки. В целом это неплохая заготовка для выполнения задания по строкам, так как она полностью реализует чтение и запись больших файлов.

В подкаталог \verb|data| я добавил примеры различных файлов, которые можно читать. Обычно в этот же подкаталог я сохраняю результаты записи. При этом настройки эмулятора, которые сейчас использую, описаны в начале этого раздела. То есть, установлен текущий каталог в качестве рабочего каталога. Также для ввода консольных данных использую всплывающее окно, так как в ряде случаев оно удобно (при отсутствии подсказки), а результат ввода все равно потом дублируется в консоли.

\section{Домашнее задание}


Написать подпрограмму, осуществляющую копирование строки символов аналогично функции strncpy языка программирования C. Протестировать функцию на различных комбинациях данных. Ознакомиться с функцией можно в системе справки по библиотеке языка C, которая имеется в различных источниках информации. Исходные данные для тестирования задавать как при вводе с консоли, так и с использованием строк символов в разрабатываемой программе (по аналогии с программами, рассмотренными на семинаре). Подпрограмму вынести в отдельный файл.

Опционально до +2 баллов

Дополнительно к подпрограмме разработать соответствующий макрос, расширив тем самым макробиблиотеку строк символов.


\textbf{\textit{Срок сдачи задания: через неделю после его выдачи. К следующему семинарскому занятию своей группы.}}