\chapter[Арифметика с плавающей точкой. Примеры]{Семинар 10. Математический сопроцессор. Арифметика с плавающей точкой. Окончание}

Завершение темы сопровождается рядом примеров. Возможно их не так много. Но пока в голову больше не лезет. В качестве дополнения можно рассмотреть дополнительное оформление в виде подпрограмм и макросов, обеспечивающих повышение юзабилити.

На занятии предполагается рассмотреть следующие примеры:
\begin{enumerate}
    \item Предварительная проверка числа перед выполнением вычислений на примере вычисления квадратного корня.
    \item Вычисление площади треугольника по формуле Герона.
    \item Вычисление числа $e$ с заданной точностью.
\end{enumerate}


\section{Примеры вычислений с плавающей точкой}

Специфической особенностью арифметики с плавающей точкой является отсутствие точных проверок чисел на равенство. Помимо этого часто различные вычисления осуществляются приближенно с заданной точностью.

\subsection{Предварительная проверка числа перед выполнением вычислений на примере вычисления квадратного корня}

Ниже представлено (из Г. Курячего) вычисление квадратного корня из целого числа, с предварительной проверкой его на положительное значение уже в регистре арифметического сопроцессора:

\begin{verbatim}
    li      a7 5
    ecall                   # Ввод целого
    fcvt.s.w ft1 a0         # Преобразование в вещественное
    fmv.s.x ft0 zero        # 0 не надо преобразовывать!
    flt.s   t0 ft1 ft0      # t0 = ft1 < 0 ?
    fmv.s   fa0 ft0         # результат пока 0...
    bnez    t0 negat        # ... и останется 0, если число отрицательное
    fsqrt.s fa0 ft1         # вычислим корень
    negat:  li      a7 2            # выведем результат
    ecall
    li      a7 10
    ecall
\end{verbatim}

\debate[Примечание]{Код простой. Поэтому со вспомогательными сообщениями решил не мудрить.}

\subsection{Вычисление площади треугольника по формуле Герона}

В примере рассматривается простое решение, связанное с вычислением плошади треугольника по формуле:
$S = \sqrt{p*(p-a)*(p-b)*(p-c)}$
где
$a, b, c$ - стороны треугольника,
$p = (a+b+c)/2$.

Простая программа (triangle-area) выглядит следующим образом:
\begin{verbatim}
    .data
    yes:    .asciz  "It is a triangle\n"
    no:     .asciz  "It is not a triangle\n"
    area:   .asciz  "Area = \n"
    .text
    # Последовательный ввод трех сторон
    jal     input
    fmv.s   fs2 fa0
    jal     input
    fmv.s   fs1 fa0
    jal     input
    fmv.s   fa1 fs1
    fmv.s   fa2 fs2

    jal     check      # Вызов проверки на треугольник

    # Это не треугольник
    bnez    a0 true
    la      a0 no
    li      a7 4
    ecall
    b       exit

    # Это треугольник.
    true:   la      a0 yes
    li      a7 4
    ecall
    jal     geron   # Вычисление площади
    li		a7 2	# Вывод площади
    ecall
    exit:
    li      a7 10
    ecall

    # Ввод стороны треугольника
    .data
    prompt: .ascii  "Enter triangle side: "
    .text
    input:  la      a0 prompt
    li      a7 4
    ecall
    li      a7 6
    ecall
    ret

    # Проверка, что это стороны треугольника
    check:  fadd.s  ft0 fa1 fa2
    flt.s   t0 fa0 ft0
    fadd.s  ft1 fa2 fa0
    flt.s   t1 fa1 ft1
    fadd.s  ft2 fa1 fa0
    flt.s   t2 fa2 ft2
    and     a0 t0 t1
    and     a0 a0 t2
    ret

    # Вычисление площади по формуле Герона
    # Стороны остались в регистрах - параметрах
    .data
    double_two: .float 2.0
    .text
    geron:
    # Вычисления полупериметра
    fadd.s 	ft0 fa0 fa1
    fadd.s 	ft0 ft0 fa2
    flw		ft2 double_two t0
    fdiv.s 	ft0 ft0 ft2
    # Вычисление разностей
    fsub.s	ft3 ft0 fa0
    fsub.s	ft4 ft0 fa1
    fsub.s	ft5 ft0 fa2
    # Их перемножение
    fmul.s	ft1 ft3 ft4
    fmul.s	ft1 ft1 ft5
    fmul.s	ft1 ft1 ft0
    # Получение площади
    fsqrt.s	fa0 ft1
    ret
\end{verbatim}


\subsection{Вычисление числа $e$ с заданной точностью}

Пример (\verb|exp.s|) такой же как и у Курячего. Только взят из другого источника. Поэтому комментарии на английском. Вычисляет число $e$ по формуле:

$\exp = 1/n! + 1/(n-1)! + ...$

Точность задается формулой:

$\epsilon = 1/(10 ** k))$

Добавил подсказку для ввода  данных с использованием библиотеки макроопределений.

\begin{verbatim}
    #
    # Example: calculates e as an infinite sum: 1/n! + 1/(n-1)! + ...
    #          with the specified precision epsilon = 1/(10 ** k))
    #
    .include "common.mac"
    .data
    one:
    .double 1
    ten:
    .double 10

    .text
    main:
    fld     f2, one, t0   # 1
    fsub.d  f4, f4, f4    # n = 0
    fmv.d   f6, f2        # n!
    fmv.d   f8, f2        # here will be e
    fld     f10, ten, t0  # here will be epsilon
    fmv.d   f0, f2        # decimal length k

    print_str("Введите число точных разрядов: ")
    read_int_a0
    enext:
    blez    a0, edone     # 10 ** (k+1)
    fmul.d  f0, f0, f10
    addi    a0, a0, -1
    j       enext
    edone:
    fdiv.d  f10, f2, f0   # epsilon

    loop:
    fadd.d  f4, f4, f2    # n = n+1
    fmul.d  f6, f6, f4    # n! = (n-1)! * n
    fdiv.d  f0, f2, f6    # next summand
    fadd.d  f8, f8, f0
    flt.d   t0, f0, f10   # next summand < epsilon
    beqz    t0, loop

    li      a7, 3         # output a double
    fmv.d   fa0, f8
    ecall
\end{verbatim}

\section{Домашнее задание}

\debate[Примечание]{\textbf{\textit{Домашнее задание на арифметику с плавающей точкой не выдаем. Текст оставляю на будущее (на всякий случай, чтобы не вспоминать). Компенсируется индивидуальным заданием по этой теме.}}}

\textbf{До 8 баллов}

Написать программу, осуществляющую вычисление корня квадратного из положительного числа с заданной точностью, используя для этого соответствующую итерационную формулу. В качестве исходных данных вводятся  исходное действительное число и точность вычислений, задаваемая также действительным числом. Вычисление корня оформить как отдельную подпрограмму, принимающую значение аргумента и точность, которая возвращает в качестве результата полученную величину квадратного корня. Основная программа осуществляет ввод исходного числа и точности с консоли с проверкой на корректные значения, а также вывод результата.

\textbf{Опционально до +2 баллов}

Обернуть ввод исходных данных и их проверку, вывод результата вычислений, вызов подпрограммы вычисления квадратного корня в отдельные макроопределения. Эти макроопределения оформить в отдельном файле, подключаемом к основной программе вместо описания в ней глобальных точек. Подпрограмма вычисления квадратного корня также должна находиться в отдельном файле.

При выполнении задания разработать только одну программу с учетом целевой оценки.

\debate[TODO]{Я сформировал весь материал. Вопрос в его общем представлении. В принципе на псевдоинструкциях можно особо не заморачиваться. Возможно на три занятия может и не хватить. Думаю, что стоит подумать в этом случае, что добавить.}
