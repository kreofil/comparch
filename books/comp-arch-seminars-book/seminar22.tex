\chapter[22]{Семинар 22. }

\chapter{Семинар 22. Мультипроцессоры. Специализированные процессоры}

Целью семинара является изучение основных принципов подхода, направленного на создание архитектурно-независимых параллельных программ. Основная идея связана с тем, чтобы при разработке программ сделать основной акцент на функциональные и алгоритмические зависимости, максимально абстрагировавшись от использования вычислительных ресурсов.

Для изучения подхода предлагается использовать функционально-потоковую парадигму параллельного программирования. Ее описание, а также язык и IDE представлены на сайте по ссылке: \url{http://softcraft.ru/parallel/fpp/}. В рамках семинара предлагается изучить основные идеи подхода и разобрать особенности построения функционально потоковых параллельных (ФПП) программ. Среда функционирует под Виндой. Программы и сама среда выложены в ЛМС.

Примерный порядок проведения семинара:
\begin{enumerate}
    \item Первоначально предлагается установить и запустить среду. Посмотреть на ее основные элементы управления. Можно практически сразу загрузить файл с множеством функций и на его примере рассмотреть особенности конструкции языка и их использование для описания параллельных вычислений. При этом имеет смысл пользоваться тем описанием, которое лежит на сайте. В целом там вполне понятное описание. Если что по нему непонятно, то могу пояснить.
    \item Далее можно начать понемногу рассматривать основные фунции и оснобенности работы с ними по порядку. На примере функции
    \begin{verbatim}
        ParASMD << funcdef Param
        {
         Param:[+,-,*,/,%]:(.) >>return
        };
    \end{verbatim}
    можно показать, как задается одновременность в обработке одного потока данных. Аргументами функции, задаваемым в табе аргументов может служить любой двухэлементный список. Можно, используя примеры ниже, запускать функцию с любыми тестовыми данными. В приведенных тестовых примерах функции как бы запускаются внутри параллельного списка. То есть, <<одновременно>>. Одновременность была бы при наличии соответствующего параллельного интерпретатора. Можно также пробежаться с пошаговым отладчиком по фунции, чтобы посмотреть как он работает.
    \item На функции вычисления абсолютной величины можно рассмотреть каким образом задаются условия и организуются ветвления.
    \begin{verbatim}
        Abs << funcdef Param
        {
         ({Param:-},{Param}):[(Param,0):(<,=>):?]:.>>return
        };
   \end{verbatim}
   Особенность в том, что нет ветвления потоков, а имеется их выборка из альтернативных вариантов. То есть, поток всегда есть и сводися в общий путь. При этом для того, чтобы ненужные вычисления не выполнялись, используется задержанный список (\verb|{...}|.
   \item При вычислении квадратного корня используется обычный последовательный алгоритм. В принципе здесь можно рассмотреть, как он отображается на информационный граф, когда отстутствует явное управление вычислениями, а используется управленипе по готовности данных. Можно в принципе особо и не рассматривать.
   \item Далее можно остановиться на организации параллельной рекурсии.
   \begin{verbatim}
    VSum << funcdef Param
    {
     Len<<Param:|;
     return<< .^[((Len,2):[<,=,>]):?]^
     ({Param:[]},
     {Param:+},
     {block{
            OddVec<< Param:[(1,Len,2):..];
            EvenVec<< Param:[(2,Len,2):..];
            ([OddVec,EvenVec]:VSum):+ >>break}
     })
    };
   \end{verbatim}
   Пояснить специфику разделения списка данных (вектора) на два посписка, на каждым из которых снова может выполняться дихотомия. В данном случае идет разделение по четным и нечетным элементам. До списка с одним или двумя элементами. Над последним выполняется суммирование, результат поднимается вверх и суммируется с результатом из другого подсписка.
   \item Аналогичный прием можно обобщить на функции высшего порядка.
   \begin{verbatim}
    VHigh << funcdef Param
    {
     Len<<Param:1:|;
     Func<<Param:2;
     return<< .^[((Len,2):[<,=,>]):?]^
     ({Param:1:[]},
     {Param:1:Func},
     {block{
            OddVec<< Param:1:[(1,Len,2):..];
            EvenVec<< Param:1:[(2,Len,2):..];
            ([(OddVec, Func),(EvenVec,Func)]:VHigh):Func >>break}
     })
    };
    \end{verbatim}
    Основная идея здесь заключается в передаче функции в качестве аргумента. Это используется в тестовых примерах.
    \item Далее приведены различные функции работы с векторами. Их можно рассмотреть более бегло, останавливаясь только на конструкциях вызывающих вопросы. Ответы на большую часть вопросов можно получить по ссылке, указанной выше.
    \item И на закуску, если останется время, можно рассмотреть параллельную интерпретацию задачи о Ханойской башне и сортировки, представленные в виде отдельных файлов.
\end{enumerate}

\section{Домашнее задание}

Скорее всего выдавать не стоит, так как дедлайн остается занятие для разбора полетов и то не у всех.
